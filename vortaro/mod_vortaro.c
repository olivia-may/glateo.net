/* 
**  mod_vortaro.c -- Apache sample vortaro module
**  [Autogenerated via ``apxs -n vortaro -g'']
**
**  To play with this sample module first compile it into a
**  DSO file and install it into Apache's modules directory 
**  by running:
**
**    $ apxs -c -i mod_vortaro.c
**
**  Then activate it in Apache's apache2.conf file for instance
**  for the URL /vortaro in as follows:
**
**    #   apache2.conf
**    LoadModule vortaro_module modules/mod_vortaro.so
**    <Location /vortaro>
**    SetHandler vortaro
**    </Location>
**
**  Then after restarting Apache via
**
**    $ apachectl restart
**
**  you immediately can request the URL /vortaro and watch for the
**  output of this module. This can be achieved for instance via:
**
**    $ lynx -mime_header http://localhost/vortaro 
**
**  The output should be similar to the following one:
**
**    HTTP/1.1 200 OK
**    Date: Tue, 31 Mar 1998 14:42:22 GMT
**    Server: Apache/1.3.4 (Unix)
**    Connection: close
**    Content-Type: text/html
**  
**    The sample page from mod_vortaro.c
*/ 

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <sys/stat.h>

#include "httpd.h"
#include "http_config.h"
#include "http_protocol.h"
#include "ap_config.h"
#include "apr_strings.h"
#include "vortaro.h"

// what language the user is using the website in
enum {
    ESPERANTO = 0,
    ENGLISH
};

char *eo_vortaro_page = NULL;

char *en_vortaro_page = NULL; 

// From apache2 modguide
typedef struct {
    char *key;
    char *value;
} keyValuePair;
// End apache2 modguide

void convert_to_proper_esperanto(char *input_word) {
    bool is_x_or_h;

    for (int i = 0; i < strlen(input_word) - 1; i++) {
        
        is_x_or_h = input_word[i + 1] == 'x' || input_word[i + 1] == 'h';
        
        if (input_word[i] == 'c' && is_x_or_h) {
            
            input_word[i] = 196;
            i++;
            input_word[i] = 137;
        }
        if (input_word[i] == 'g' && is_x_or_h) {
            
            input_word[i] = 196;
            i++;
            input_word[i] = 157;
        }
        if (input_word[i] == 'h' && is_x_or_h) {
            
            input_word[i] = 196;
            i++;
            input_word[i] = 165;
        }
        if (input_word[i] == 'j' && is_x_or_h) {
            
            input_word[i] = 196;
            i++;
            input_word[i] = 181;
        }
        if (input_word[i] == 's' && is_x_or_h) {
            
            input_word[i] = 197;
            i++;
            input_word[i] = 157;
        }
        if (input_word[i] == 'u' && is_x_or_h) {
            
            input_word[i] = 197;
            i++;
            input_word[i] = 173;
        }
    }
}

char *search_dictionary_eo(const int to_language,
    const char *input_word) {

    int i, j;
    char *definition;
    int definition_len, eo2_len, to_language_len;

    definition = malloc(sizeof(char));
    definition[0] = '\0';

    for (i = 0; i < DICTIONARY_LEN; i++) {

        for (j = 0; j < strlen(input_word); j++) {
            
            if (dictionary[i][EO1][j] == '\0') break;        
            if (input_word[j] != dictionary[i][EO1][j]) break;        
            if (j == strlen(input_word) - 1) {
            
                definition_len = strlen(definition);
                eo2_len = strlen(dictionary[i][EO2]);
                to_language_len = strlen(dictionary[i][to_language]);

                // + 15 because "<br>&emps;" length, length of ending <br>, and
                // null char
                definition =
                    realloc(definition, 
                    (definition_len + eo2_len + to_language_len + 15)
                    * sizeof(char));
                
                strcpy(&definition[definition_len], dictionary[i][EO2]);
                strcpy(&definition[definition_len + eo2_len], "<br>&emsp;");
                // + 10 because "<br>%emps;" length
                strcpy(&definition[definition_len + eo2_len + 10],
                    dictionary[i][to_language]);
                strcpy(&definition[definition_len + eo2_len + 10 + to_language_len],
                    "<br>");
            }
        }
    }

    return definition;
}

char *search_dictionary(const char *wl[][2], const int wordlist_len,
    const char *input_word) {

    int i, j;
    char *definition;
    int definition_len, from_len, to_len;

    definition = malloc(sizeof(char));
    definition[0] = '\0';

    for (i = 0; i < wordlist_len; i++) {

        for (j = 0; j < strlen(input_word); j++) {
            
            if (input_word[j] != wl[i][FROM][j]) break;
            
            if (j == strlen(input_word) - 1) {
            
                definition_len = strlen(definition);
                from_len = strlen(wl[i][FROM]);
                to_len = strlen(wl[i][TO]);
                
                // + 15 because "<br>&emps;" length, length of ending <br>, and
                // null char
                definition =
                    realloc(definition, 
                    (definition_len + from_len + to_len + 15)
                    * sizeof(char));
                
                strcpy(&definition[definition_len], wl[i][FROM]);
                strcpy(&definition[definition_len + from_len], "<br>&emsp;");
                // + 10 because "<br>%emps;" length
                strcpy(&definition[definition_len + from_len + 10], wl[i][TO]);
                strcpy(&definition[definition_len + from_len + 10 + to_len], "<br>");
            }
        }
    }

    return definition;
}

// From apache2 modguide
keyValuePair *readPost(request_rec *r) {
    apr_array_header_t *pairs = NULL;
    apr_off_t len;
    apr_size_t size;
    int res;
    int i = 0;
    char *buffer;
    keyValuePair *kvp;

    res = ap_parse_form_data(r, NULL, &pairs, -1, HUGE_STRING_LEN);
    if (res != OK || !pairs) return NULL; /* Return NULL if we failed or if there are is no POST data */
    kvp = apr_pcalloc(r->pool, sizeof(keyValuePair) * (pairs->nelts + 1));
    while (pairs && !apr_is_empty_array(pairs)) {
        ap_form_pair_t *pair = (ap_form_pair_t *) apr_array_pop(pairs);
        apr_brigade_length(pair->value, 1, &len);
        size = (apr_size_t) len;
        buffer = apr_palloc(r->pool, size + 1);
        apr_brigade_flatten(pair->value, buffer, &size);
        buffer[len] = 0;
        kvp[i].key = apr_pstrdup(r->pool, pair->name);
        kvp[i].value = buffer;
        i++;
    }
    return kvp;
}
// End apache2 modguide

char *get_file_contents(const char *path, apr_pool_t *p) {
    FILE *file;
    char *file_contents;
    struct stat statinfo;
    long int size;

    file = fopen(path, "r");
    stat(path, &statinfo);
    // + 1 because null char
    file_contents = (char *)apr_palloc(p, (statinfo.st_size + 1) * sizeof(char));
    if (!file_contents) {
        fprintf(stderr, "apr_palloc failed\n");
        exit(2);
    }
    int i = 0;
    int ch;
    while (true) {
        ch = fgetc(file);
        if (ch < 0) break;
        file_contents[i] = ch;
        i++;
    }
    file_contents[i] = '\0';
    fclose(file);

    return file_contents;
}

/* The sample content handler */
static int vortaro_handler(request_rec *r) {
#define PRINT_PAGE(page, word_not_found_str) \
\
while (page[i] != '\0') { \
\
    /* 23 len of ?vtro_xx_to_yy_selected */ \
    if (!strncmp(&page[i], \
        "?vrtr_eo_to_en_selected", 23)) { \
\
        if (!strcmp(r->method, "POST")) { \
            if (!strcmp(kvp[1].value, "eo_to_en")) { \
                ap_rputs("selected=\"selected\"", r); \
            } \
        } \
\
        i += 23; \
    } \
    if (!strncmp(&page[i], \
        "?vrtr_en_to_eo_selected", 23)) { \
\
        if (!strcmp(r->method, "POST")) { \
            if (!strcmp(kvp[1].value, "en_to_eo")) { \
                ap_rputs("selected=\"selected\"", r); \
            } \
        } \
\
        i += 23; \
    } \
\
    /* `16` len of ?vrtr_definition */ \
    if (!strncmp(&page[i], "?vrtr_definition", 16)) { \
\
        if (!strcmp(r->method, "POST")) { \
\
            /* if "word".value is only null char (no input) */ \
            if (!kvp[0].value[0]) \
                break; \
\
            convert_to_proper_esperanto(kvp[0].value); \
\
            if (!strcmp(kvp[1].value, "eo_to_en")) { \
                definition = search_dictionary_eo(EN, kvp[0].value); \
            } \
            else if (!strcmp(kvp[1].value, "en_to_eo")) { \
                definition = search_dictionary(en_to_eo, EN_TO_EO_LEN, \
                    kvp[0].value); \
            } \
\
            if (!definition[0]) \
                ap_rputs(word_not_found_str, r); \
            else \
                ap_rputs(definition, r); \
\
            free(definition); \
        } \
\
        i += 16; \
    } \
\
    ap_rputc(page[i], r); \
    i++; \
}

    int language;
    keyValuePair *kvp;
    char *definition;
    int i = 0;

    if (!strcmp(r->uri, "/eo/vortaro")) {
        language = ESPERANTO;
    }
    else if (!strcmp(r->uri, "/en/vortaro")) {
        language = ENGLISH;
    }
    else
        return DECLINED;
    
    r->content_type = "text/html";
    
    if (!r->header_only) {
                
        if (!strcmp(r->method, "POST"))
            kvp = readPost(r);

        switch (language) {

            case ESPERANTO: {
                PRINT_PAGE(eo_vortaro_page,
                    "La vorto ne estis trovita, provu alian vorton.")
            } break;
            case ENGLISH:
                PRINT_PAGE(en_vortaro_page,
                    "Word not found, try another word.");
                break;
        }
    }
    return OK;
}

// TODO figure out why this function gets called twice, and make it
// not open the files twice
static void vortaro_register_hooks(apr_pool_t *p)
{
    ap_hook_handler(vortaro_handler, NULL, NULL, APR_HOOK_MIDDLE);

    // TODO: change `html/` to `glateo.net/`
    if (!eo_vortaro_page) {
        eo_vortaro_page = get_file_contents("/var/www/html/eo/vortaro", p);
    }
    if (!en_vortaro_page) {
        en_vortaro_page = get_file_contents("/var/www/html/en/vortaro", p);
    }
}

/* Dispatch list for API hooks */
module AP_MODULE_DECLARE_DATA vortaro_module = {
    STANDARD20_MODULE_STUFF, 
    NULL,                  /* create per-dir    config structures */
    NULL,                  /* merge  per-dir    config structures */
    NULL,                  /* create per-server config structures */
    NULL,                  /* merge  per-server config structures */
    NULL,                  /* table of config file commands       */
    vortaro_register_hooks  /* register hooks                      */
};

